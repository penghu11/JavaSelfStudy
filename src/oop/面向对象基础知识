 * 三、面向对象的两个要素：
 * 类:对一类事物的描述，是抽象的、概念上的定义
 * 对象:是实际存在的该类事物的每个个体，因而也称为实	例(instance)。
 * 可以理解为：类= 抽象概念的人；对象= 实实在在的某个人
 * 面向对象程序设计的重点是类的设计；
 * 设计类，其实就是设计类的成员。

  一、设计类、其实就是设计类的成员
  * Field = 属性 = 成员变量 = 域、字段
  * Method = (成员)方法 = 函数
  *
  * 创建类 = 类的实例化 = 实例化类
  *
  * 二.类和对象的使用(面向对象思想落地的实现)
  * 1.创建类，设计类的成员
  * 2.创建类的对象
  * 3.通过“对象.属性”或“对象.方法”调用对象的结构
  * 三、如果创建类一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非 static 的)
  * 	  意味着:如果我们修改一个对象的属性 a，则不影响另外一个对象属性 a 的值。

/*
 * 类的语法格式：
 * 修饰符 class 类名{
 * 		属性声明;
 * 		方法声明;
 * }
 * 说明：修饰符 public：类可以被任意访问类的正文要用{  }括起来
 */


 类的成员之一：属性

 /*
  * 类中属性的使用
  *
  * 属性(成员变量)	vs	局部变量
  * 1.相同点:
  * 		1.1 定义变量的格式:数据类型 变量名 = 变量值
  * 		1.2 先声明，后使用
  * 		1.3 变量都有其对应的作用域
  *
  * 2.不同点:
  * 		2.1 在类中声明的位置不同
  * 		属性:直接定义在类的一对{}内
  * 		局部变量:声明在方法内、方法形参、构造器形参、构造器内部的变量
  *
  * 		2.2 关于权限修饰符的不同
  * 		属性:可以在声明属性时，指明其权限，使用权限修饰符。
  * 			常用的权限修饰符:private、public、缺省、protected
  * 			目前声明属性时，都使用缺省即可。
  * 		局部变量:不可以使用权限修饰符。
  *
  * 		2.3 默认初始化值的情况:
  * 		属性:类的属性，根据其类型，都有默认初始化值。
  * 			整型(byte、short、int、long):0
  * 			浮点型(float、double):0.0
  * 			字符型(char):0(或‘\u0000’)
  * 			布尔型(boolean):false
  *
  * 			引用数据类型(类、数组、接口):null
  *
  * 		局部变量:没有默认初始化值
  * 			意味着:在调用局部变量之前，一定要显式赋值。
  * 			特别地:形参在调用时,赋值即可。例，45 行
  *
  * 		2.4 在内存中加载的位置，亦各不相同。
  * 		属性:加载到堆空间中(非 static)
  * 		局部变量:加载到栈空间
  */
类中方法的声明和使用
   *
   * 方法：描述类应该具有的功能。
   * 比如：Math类：sqrt()\random() \...
   *     Scanner类：nextXxx() ...
   *     Arrays类：sort() \ binarySearch() \ toString() \ equals() \ ...
   *
   * 1.举例：
   * public void eat(){}
   * public void sleep(int hour){}
   * public String getName(){}
   * public String getNation(String nation){}
   *
   * 2. 方法的声明：权限修饰符  返回值类型  方法名(形参列表){
   * 					方法体
   * 			  }
   *   注意：static、final、abstract 来修饰的方法，后面再讲。
   *
   * 3. 说明：
   * 		3.1 关于权限修饰符：默认方法的权限修饰符先都使用public
   * 			Java规定的4种权限修饰符：private、public、缺省、protected  -->封装性再细说
   *
   * 		3.2 返回值类型： 有返回值  vs 没有返回值
   * 			3.2.1  如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用
   *                return关键字来返回指定类型的变量或常量：“return 数据”。
   * 				  如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要
   *               使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。
   *
   * 			3.2.2 我们定义方法该不该有返回值？
   * 				① 题目要求
   * 				② 凭经验：具体问题具体分析
   *
   *      3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”
   *      3.4 形参列表:方法名可以声明0个、1个，或多个形参。
   *      	3.4.1 格式:数据类型1 形参1，数据类型2 形参2,...
   *
   *      	3.4.2 我们定义方法时，该不该定义形参？
   *      		① 题目要求
   *      		② 凭经验，具体问题具体分析
   *      3.5 方法体:方法功能的体现。
   *  4. return关键字的使用：
   *  	1.使用范围:使用在方法体中
   *  	2.作业:① 结束方法
   *  		  ② 针对于有返回值类型的方法，使用"return 数据"方法返回所要的数据。
   *  	3.注意点:return关键字后不可声明执行语句。
   *  5. 方法的使用中，可以调用当前类的属性或方法。
   *  		特殊的:方法A中又调用了方法A:递归方法。
   *  	方法中不能定义其他方法。

方法的重载(overload) loading...
    *
    * 1.定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
    *
    * 		“两同一不同”:同一个类、相同方法名
    * 				  参数列表不同：参数个数不同，参数类型不同
    *
    * 2.举例:
    * 		Arrays类中重载的sort() / binarySearch()
    *
    * 3.判断是否重载
    * 		与方法的返回值类型、权限修饰符、形参变量名、方法体都无关。
    *
    * 4.在通过对象调用方法时，如何确定某一个指定的方法：
    * 		方法名---》参数列表
    */

     * 可变个数形参的方法
     * 1.jdk 5.0新增的内容
     * 2.具体使用：
     * 	2.1 可变个数形参的格式：数据类型 ... 变量名
     * 	2.2 当调用可变个数形参的方法时，传入的参数的个数可以是：0个，1个，2个...
     * 	2.3可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。
     *  2.4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。即二者不可共存。
     *  2.5可变个数形参在方法中的形参中,必须声明在末尾。
     *  2.6可变个数形参在方法中的形参中，最多只能声明一个可变形参。

方法参数的值传递机制(重点！！！)

/*
 * 关于变量的赋值
 *
 * 	如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
 * 	如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。
 *
 */

 针对基本数据类型

 /*
  * 方法的形参的传递机制：值传递
  *
  * 1.形参：方法定义时，声明的小括号内的参数
  *   实参：方法调用时，实际传递给形参的数据
  *
  * 2.值传递机制：
  *  如果参数是基本数据类型，此时实参赋值给形参的是实参真是存储的数据值。
  */

  面向对象特征之一：封装与隐藏
  意义：为了不想让外部随意对类中的属性更改，将属性私有化，
       但是这样外部不能使用类内部的属性，通过提供public get/set方法给外部调用解决。



  面向对象的特征一:封装与隐藏
   * 一、问题的引入：
   *    当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到
   *    属性的数据类型和存储范围的制约。但除此之外，没有其他制约条件。但是，实际问题中，我们往往需要给属性赋值
   *    加入额外限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行条件的添加。比如说，setLegs
   *    同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private)
   *    --》此时，针对于属性就体现了封装性。
   *
   * 二、封装性的体现：
   *    我们将类的属性私有化(private),同时,提供公共的(public)方法来获取(getXxx)和设置(setXxx)
   *
   *    拓展：封装性的体现：① 如上 ② 单例模式 ③ 不对外暴露的私有方法
   *
   */
  类的成员变量权限修饰：
        public、protected、default(缺省)、private 置于类的成员定义前，用来限定对象对该类成员的访问权限。

  对于 class 的权限修饰只可以用 public 和 default(缺省)。
      public 类可以在任意地方被访问。
      default 类只可以被同一个包内部的类访问。

   * 三、封装性的体现，需要权限修饰符来配合。
   *   1.Java 规定的 4 种权限：(从小到大排序)private、缺省、protected、public
   *   2.4 种权限用来修饰类及类的内部结构：属性、方法、构造器、内部类
   *   3.具体的，4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
   * 		 修饰类的话，只能使用：缺省、public
   *  总结封装性：Java 提供了 4 中权限修饰符来修饰类积累的内部结构，体现类及类的内部结构的可见性的方法。
   *
        private :只能在类内部使用，出了类就不能用
        缺省：同一个包内用
        protected:不同包的子类可用
        public ：同一个工程可用
   */

   类的结构之三:构造器(构造方法、constructor)的使用
    * constructor:
    *
    * 一、构造器的作用:
    * 1.创建对象
    * 2.初始化对象的属性
    *
    * 二、说明
    * 1.如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器。
    * 2.定义构造器的格式:
    * 			权限修饰符  类名(形参列表) { }
    * 3.一个类中定义的多个构造器，彼此构成重载。
    * 4.一旦显示的定义了类的构造器之后，系统不再提供默认的空参构造器。
    * 5.一个类中，至少会有一个构造器

this 调用属性、方法、构造器
/*
 * this 关键字的使用
 * 1.this 用来修饰、调用：属性、方法、构造器
 * 2.this 修饰属性和方法:
 * 		this 理解为：当前对象,或当前正在创建的对象。
 *
 *  2.1 在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性和方法。
 *  	通常情况下，我们都选择省略“this.”。特殊情况下，如果方法的形参和类的属性同名，我们必须显式
 *  	的使用"this.变量"的方式，表明此变量是属性，而非形参。
 *
 *  2.2 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用正在创建的对象属性和方法。
 *  	但是，通常情况下，我们都选择省略“this.”。特殊情况下，如果构造器的形参和类的属性同名，我们必须显式
 *  	的使用"this.变量"的方式，表明此变量是属性，而非形参。
 *
 *  3.this 调用构造器
 *  	① 我们可以在类的构造器中，显式的使用"this(形参列表)"的方式，调用本类中重载的其他的构造器！
 *  	② 构造器中不能通过"this(形参列表)"的方式调用自己。
 *  	③ 如果一个类中声明了n个构造器，则最多有n -1个构造器中使用了"this(形参列表)"。
 *  	④ "this(形参列表)"必须声明在类的构造器的首行！
 *  	⑤ 在类的一个构造器中，最多只能声明一个"this(形参列表)"。
 */

一、package 关键字的使用
 * 1.为了更好的实现项目中类的管理，提供包的概念
 * 2.使用 package 声明类或接口所属的包，声明在源文件的首行
 * 3.包，属于标识符，遵循标识符的命名规则、规范"见名知意"
 * 4.每“.”一次,就代表一层文件目录。
 *
 * 补充:同一个包下，不能命名同名接口或同名类
 *     不同包下，可以命名同名的接口、类。

 二、import关键字的使用
  * import:导入
  * 1.在源文件中显式的使用import结构导入指定包下的类、接口
  * 2.声明在包的声明和类的声明之间
  * 3.如果需要导入多个结构，则并列写出即可
  * 4.可以使用"xxx.*"的方式,表示可以导入xxx包下的所有结构。
  * 5.如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。
  * 6.如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。
  * 7.如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。
  * 8.import static组合的使用：调用指定类或接口下的静态的属性或方法.


MVC 设计模式  重要！！网上自行查下怎么设计的

    MVC 是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，数据模型层。
这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，
同时也描述了程序各个对象间的通信方式，降低了程序的耦合性



面向对象的特征二:继承性
 * 为什么要有继承？
 * 		多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，
 * 		那么多个类无需再定义这些属性和行为，只要继承那个类即可。
 * 一、继承性的好处
 *      ① 减少了代码的冗余，提高了代码的复用性；
 *      ② 便于功能的扩展；
 *      ③ 为之后多态性的使用，提供了前提。
 *
 * 二、继承性的格式
 * 	class A extends B{}
 *  A:子类、派生类、subclass
 *  B:父类、超类、基类、superclass
 *
 *  2.1 体现：一旦子类 A 继承父类以后，子类 A 中就获取了父类 B 中声明的结构：属性、方法
 * 		特别的，父类中声明为 private 的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。
 * 		只有因为封装性的影响，使得子类不能直接调用父类的结构而已。
 *  2.2 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展。
 *  	子类和父类的关系：不同于子集与集合的关系。
 *  	extends:延展、扩展

 /*  三、Java 中关于继承性的规定：
  *  	1.一个类可以被多个类继承
  *  	2.Java 中类的单继承性：一个类只能有一个父类
  *  	3.子父类是相对的概念。
  *  	4.子类直接继承的父类，称为：直接父类。间接继承的父类，称为，间接父类。
  *  	5.子类继承父类后，就获取了直接父类以及所有间接父类中声明的属性和方法。
  *
  * 四、   1.如果我们没有显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类
  * 	  2.所有的 java 类(除 java.long.Object 类之外)都直接或间接地继承于 java.lang.Object 类;
  * 	  3.意味着，所有的 java 类具有 java.lang.Object 类声明的功能。

方法的重写(override/overwrite) ：发生在子父类间，是因为父类的某个方法不适合子类，子类需要对父类的方法进行重写
 *
 * 1.重写：子类继承父类以后，可以对父类中的方法进行覆盖操作。
 * 2.应用：重写以后，当创建子类对象以后，通过子类对象去调用子父类中同名同参数方法时，执行的是子类重写父类的方法。
 *   即在程序执行时，子类的方法将覆盖父类的方法。
 *
 * 面试题：区分方法的重载与重写(有的书也叫做“覆盖”)
 * 		答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。
 * 		重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。
 * 		如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。
 * 		子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。
 * 		如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。
 *
3.重写的规定：
 * 		方法的声明：权限修饰符 返回值类型 方法名(形参列表){
 * 						//方法体
 * 				 }
 * 		约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法。
 * 		① 子类重写的方法的方法名和形参列表必须和父类被重写的方法的方法名、形参列表相同;
 * 		② 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限,
 *   		特殊情况: 子类不能重写父类中声明为private权限的方法;//因为是私有的只能在本类中使用
 *   	③ 返回值类型:
 *   		> 父类被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void;
 *   		> 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类;
 *   		> 父类被重写的方法的返回值类型如果是基本数据类型(比如:double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须是:double)。
 *
 *   	④ 子类方法抛出的异常不能大于父类被重写的方法抛出的异常;
 *
 * 注意：子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的（不是重写）。
 * 		因为static方法是属于类的，子类无法覆盖父类的方法。


super关键字的使用
 * 1.super理解为:父类的
 * 2.super可以用来调用:属性、方法、构造器
 *
 * 3.super的使用
 * 		3.1 我们可以在子类的方法或构造器中，通过"super.属性"或"super.方法"的方式，显式的调用
 * 	父类中声明的属性或方法。但是，通常情况下，我们习惯去省略这个"super."
 * 		3.2 特殊情况:当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的
 *  使用"super.属性"的方式，表明调用的是父类中声明的属性。
 *  	3.3 特殊情况:当子类重写了父类中的方法后，我们想在子类的方法中调用父类中被重写的方法时，必须显式的
 *  使用"super.方法"的方式，表明调用的是父类中被重写的方法。
 *
 * 4.super调用构造器
 * 	  4.1  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式,调用父类中声明的指定的构造器
 * 	  4.2 "super(形参列表)"的使用，必须声明在子类构造器的首行！
 *    4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现。
 *    4.4 在构造器的首行，既没有显式的声明"this(形参列表)"或"super(形参列表)",则默认的调用的是父类中的空参构造器。super()
 *    4.5 在类的多个构造器中，至少有一个类的构造器使用了"super(形参列表)",调用父类中的构造器。

  * 子类对象实例化的全过程
  *
  * 1.从结果上看:
  * 		子类继承父类以后，就获取了父类中声明的属性或方法。
  * 		创建子类的对象中，在堆空间中，就会加载所有父类中声明的属性。
  *
  * 2.从过程上看:
  * 		当我们通过子类的构造器创建子类对象时,我们一定会直接或间接的调用其父类构造器，
  * 		直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类结构，所以才可以看到内存中有
  * 		父类中的结构，子类对象可以考虑进行调用。
  *
  * 明确:虽然创建子类对象时，调用了父类的构造器，但自始至终就创建过一个对象，即为new的子类对象。



面向对象之三:多态性
 *
 * 1.理解多态性:可以理解为一个事物的多种态性。
 * 2.何为多态性:
 * 	 对象的多态性:父类的引用指向子类的对象(或子类的对象赋值给父类的引用)
 *
 * 3.多态的使用：虚拟方法调用
 * 	有了对象多态性以后，我们在编译期，只能调用父类声明的方法，但在执行期实际执行的是子类重写父类的方法
 * 			简称：编译时，看左边；运行时，看右边。
 *
 *  若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)
 *  多态情况下，
 *  	“看左边”：看的是父类的引用（父类中不具备子类特有的方法）
 *  	“看右边”：看的是子类的对象（实际运行的是子类重写父类的方法）
 *
 *  4.多态性的使用前提：
 *  	① 类的继承关系
 *  	② 方法的重写
 *  5.对象的多态性:只适用于方法，不适用于属性(编译和运行都看左边)



 * 2.从编译和运行的角度看：
 * 重载，是指允许存在多个同名方法，而这些方法的参数不同。
 * 编译器根据方法不同的参数表，对同名方法的名称做修饰。
 * 对于编译器而言，这些同名方法就成了不同的方法。
 * 它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，
 * 即子类可以重载父类的同名不同参数的方法。所以：对于重载而言，在方法调用之前，
 * 编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
 * 而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，
 * 这称为“晚绑定”或“动态绑定”。
 *
 * 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”
 */
//面试题：多态是编译时行为还是运行时行为？


/*
 * instanceof关键字的使用
 *
 * a instanceof A:判断对象a是否是类A的实例。如果，返回true，如果不是，返回false;
 *
 * 使用情境:为了避免在向下转型时出现ClassCastException异常，我们在进行向下转型之前，先进行
 * instanceof的判断,一旦返回true,就进行向下转型。如果返回false，不进行向下转型。
 *
 * 如果a instanceof A返回true,则a instanceof B也返回true。 其中类B是类A的父类。
 *
 */
 多态是编译时行为还是运行时行为？如何证明？


    final、finally、finalize的区别？

 ==和equals的区别
  *
  * 一、回顾==的使用
  * == : 运算符
  * 1.可以使用在基本数据类型变量和引用数据类型变量中
  * 2.如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。(不一定类型要相同)
  * 	   如果比较的是引用数据类型变量：比较两个对象的地址值是否相同,即两个引用是否指向同一个对象实体
  *  补充: == 符号使用时，必须保证符号左右两边的变量类型一致。
  *
  * 二、equals()方法的使用
  * 1.是一个方法，而非运算符
  * 2.只能适用于引用数据类型。
  * 3.Object类中equals()的定义：
  * 		public boolean equals(Object obj){
  * 			return (this == obj);
  * 		}
  * 说明：Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。
  *
  * 4.像String、Date、File、包装类等都重写了Object类中的equals()方法.
  * 	 两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。
  *
  * 5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们
  * 	   就需要对Object类中的equals()进行重写。
  *
  * 重写的原则:比较两个对象的实体内容是否相同。


  单元测试方法：
  2.创建一个Java类进行单元测试。
   * 	 此时的Java类要求:①此类是公共的 ②此类提供一个公共的无参构造器
   * 3.此类中声明单元测试方法。
   *   此时的单元测试方法:方法的权限是public,没有返回值，没有形参。
   *
   * 4.此单元测试方法上需要声明注解:@Test并在单元测试类中调用:import org.junit.Test;
   * 5.声明好单元测试方法以后，就可以在方法体内测试代码。

 包装类的使用
  * 1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征
  * 		基本数据类型		包装类
  * 		byte			Byte
  * 		short			Short
  * 		int 			Integer
  * 		long			Long
  * 		float			Float
  * 		double			Double
  * 		boolean			Boolean
  * 		char			Character
  * 注意:其中Byte、Short、Integer、Long、Float、Double的父类是:Number


关键字：static

    当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，
只有通过 new 关键字才会产生出对象，这时系统才会分配内存空间给对象，其方法才可以供外部调用。
我们有时候希望无论是否产生了对象或无论产生了多少对象的情况下，某些特定的数据在内存空间里只有一份。
例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。

static 关键字的使用
 *
 * 1.static:静态的。
 * 2.static 可以用来修饰:属性、方法、代码块、内部类。
 *
 * 3.使用 static 修饰属性:静态变量(或类变量)。
 * 		3.1  属性:是否使用 static 修饰，又分为:静态属性 VS 非静态属性(实例变量)
 * 		   实例变量:我们创建了类的多个对象，每个对象都独立的拥有了一套类中的非静态属性。
 * 				当修改其中一个非静态属性时，不会导致其他对象中同样的属性值的修饰。
 * 		   静态变量:我们创建了类的多个对象，多个对象共享同一个静态变量。当通过静态变量去修改某一个变量时，
 * 				会导致其他对象调用此静态变量时，是修改过的。
 * 		3.2 static 修饰属性的其他说明:
 * 			① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用。
 * 			② 静态变量的加载要早于对象的创建。
 * 			③ 由于类只会加载一次，则静态变量在内存中也只会存在一次。存在方法区的静态域中。
 *
 * 			④ 		类变量		实例变量
 * 			类		yes			no
 * 			对象		yes			yes
 *
 * 		3.3 静态属性举例:System.out.Math.PI;
   4.使用 static 修饰方法:静态方法
  * 		① 随着类的加载而加载，可以通过"类.静态方法"的方式调用
  * 		② 			静态方法		非静态方法
  * 			类		yes			no
  * 			对象		yes			yes
  * 		③ 静态方法中，只能调用静态的方法或属性
  * 		  非静态的方法中，可以调用所有的方法或属性
  *
  * 5.static 注意点:
  * 	 5.1  在静态的方法内，不能使用 this 关键字、super 关键字
  *   5.2 关于静态属性和静态方法的使用，大家从生命周期的角度去理解。
  *
  * 6.开发中，如何确定一个属性是否需要声明 static 的？
  * 	 》 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。
  * 	 》 类中的常量也常常声明为 static
  *
  *   开发中，如何确定一个方法是否要声明为 static 的？
  *   》 操作静态属性的方法，通常设置为 static 的
  *   》 工具类中的方法，习惯上声明为 static 的。比如：Math、Arrays、Collections


  单例(Singleton)设计模式

  设计模式是**在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。
  **设计模免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。”套路”

  所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。
  并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，
  我们首先必须将类的构造器的访问权限设置为 private，这样，就不能用 new 操作符在类的外部产生类的对象了，
  但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，
  静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。

  单例设计模式:
   * 1.所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例
   *
   * 2.如何实现？
   *   饿汉式	VS	懒汉式
   *
   * 3.区分饿汉式和懒汉式。
   * 	   饿汉式：坏处:对象加载时间过长。
   * 	 	       好处:饿汉式是线程安全的。
   *
   *   懒汉式：好处:延迟对象的创建。
   * 		       坏处:目前的写法，会线程不安全。---》到多线程内容时，再修改

   3、单例模式的优点
   由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，
   则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。

   4、单例(Singleton)设计模式-应用场景

     网站的计数器，一般也是单例模式实现，否则难以同步。
     应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
     数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
     项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。
     Application也是单例的典型应用
     Windows 的 **Task Manager (任务管理器)**就是很典型的单例模式
     Windows 的 **Recycle Bin(回收站)**也是典型的单例应用。在整个系统运行过程中


  * 类的成员之四:代码块（或初始化块）
   *
   * 1.代码块的作用：用来初始化类、对象的
   * 2.代码块如果有修饰的话，只能使用 static
   * 3.分类:静态代码块 vs 非静态代码块
   *
   * 4.静态代码块
   *  》内部可以有输出语句
   *  》随着类的加载而执行,而且只执行一次
   *  》作用:初始化类的信息
   *  》如果一个类中，定义了多个静态代码块，则按照声明的先后顺序执行
   *  》静态代码块的执行，优先于非静态代码块的执行
   *  》静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
   *
   * 5.非静态代码块
   *  >内部可以有输出语句
   *  >随着对象的创建而执行
   *  >每创建一个对象，就执行一次非静态代码块。
   *  >作用:可以在创建对象时，对对象的属性等进行初始化。
   *  >如果一个类中，定义了多个非静态代码块，则按照声明的先后顺序执行
   *  >非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法。
   *
   * 对属性可以赋值的位置:
   *  ①默认初始化
   *  ②显式初始化
   *  ③构造器中初始化
   *  ④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值。
   *  ⑤在代码块中赋值

   * 对属性可以赋值的位置:
   *  ①默认初始化
   *  ②显式初始化 / ⑤在代码块中赋值
   *  ③构造器中初始化
   *  ④有了对象以后，可以通过"对象.属性"或"对象.方法"的方式，进行赋值。
   *
   *  执行的先后顺序:① - ② / ⑤ - ③ - ④


    final:最终的
    *
    * 1.final可以用来修饰的结构:类、方法、变量
    *
    * 2.final用来修饰一个类:此类不能被其他类所继承。
    * 		  比如:String类、System类、StringBuffer类
    * 3.final修饰一个方法:final标记的方法不能被子类重写。
    * 		  比如：Object类中的getClass()。
    * 4.final用来修饰变量:此时的"变量"(成员变量或局部变量)就是一个常量。名称大写，且只能被赋值一次。
    * 	 4.1 final修饰属性，可以考虑赋值的位置有:显式初始化、代码块中初始化、构造器中初始化
    *   4.2 final修饰局部变量:
    *   	 尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。
    *      一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。
    *
    * static final 用来修饰:全局常量


    05、抽象类与抽象方法

    随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一般，更通用。
    类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，
    这样的类叫做抽象类。

    * abstract 关键字的使用
     *
     * 1.abstract:抽象的
     * 2.abstract 可以用来修饰的结构:类、方法
     * 3.abstract 修饰类:抽象类
     * 	》 此类不能实例化
     *  》 抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化全过程)
     *  》 开发中，都会提供抽象类的子类，让子类对象实例化，实现相关的操作
     *
     * 4.abstract 修饰方法:抽象方法
     *  > 抽象方法，只有方法的声明，没有方法体。
     *  > 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法
     *  > 若子类重写了父类中所有的抽象方法，此子类，
     *
     * abstract 使用上的注意点:
     * 1.abstract 不能用来修饰变量、代码块、构造器；
     *
     * 2.abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类。


     5.4、多态的应用：模板方法设计模式(TemplateMethod)

     抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，
     但子类总体上会保留抽象类的行为方式。

     解决的问题：

        当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
     换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。
     但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。
     *


 接口：
     一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java 不支持多重继承。有了接口，就可以得到多重继承的效果。
     另一方面，有时必须从几个类中抽取出一些共同的行为特征，而它们之间又没有 is-a 的关系，仅仅是具有相同的行为特征而已。
        例如：鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3 机、手机、数码相机、移动硬盘等都支持 USB 连接。
     接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要…则必须能…”的思想。继承是一个"是不是"的关系，而接口实现则是"能不能"的关系。

     接口的本质是契约，标准，规范，就像我们的法律一样。制定好后大家都要遵守


/* 接口(interface)是抽象方法和常量值定义的集合。
 * 接口的特点：
 * 用 interface 来定义。
 * 接口中的所有成员变量都默认是由 public static final 修饰的。
 * 接口中的所有抽象方法都默认是由 public abstract 修饰的。
 * 接口中没有构造器。
 * 接口采用多继承机制。

 /*
  * 接口的使用
  * 1.接口使用 interface 来定义。
  * 2.在 Java 中:接口和类是并列的两个结构
  * 3.如何去定义接口:定义接口中的成员
  * 	》3.1 JDK7 及以前:只能定义全局常量和抽象方法
  * 		》全局常量:public static final 的,但是书写中，可以省略不写。
  * 		》抽象方法:public abstract 的
  *
  *  》3.2 JDK8:除了全局常量和抽象方法之外，还可以定义静态方法、默认方法(略)。
  *
  * 4.接口中不能定义构造器！意味着接口不可以实例化。
  *
  * 5.Java 开发中，接口通过让类去实现(implements)的方式来使用。
  *   如果实现类覆盖了接口中的所有方法，则此实现类就可以实例化
  *   如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类
  *
  * 6.Java 类可以实现多个接口 ---》弥补了 Java 单继承性的局限性
  *  格式:class AA extends BB implementd CC,DD,EE
  *
  *  7.接口与接口之间是继承,而且可以多继承
  *
  **********************************
  * 8.接口的具体使用，体现多态性
  * 	   接口的主要用途就是被实现类实现。（面向接口编程）
  * 9.接口，实际可以看作是一种规范


    面试题:抽象类与接口有哪些异同？


接口的应用：代理模式(Proxy)

    代理模式是 Java 开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。
 */


        知识点 1：接口中定义的静态方法，只能通过接口来调用。
 //		知识点 2：通过实现类的对象，可以调用接口中的默认方法。
 //		    如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
 //		知识点 3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，
 //		    那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。-->类优先原则
 //		知识点 4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，
 //		    那么在实现类没有重写此方法的情况下，报错。-->接口冲突。
 //		    这就需要我们必须在实现类中重写此方法


 类的内部成员之五:内部类
 *
 * 1.Java中允许将一个类A声明在另一个类B中,则类A就是内部类,类B就是外部类.
 *
 * 2.内部类的分类:成员内部类	VS	局部内部类(方法内、代码块内、构造器内)
 *
 * 3.成员内部类
 * 	》作为外部类的成员,
 * 		- 调用外部类的结构
 * 		- 可以被static修饰
 * 		- 可以被4种不同的权限修饰
 *
 *  》作为一个类，
 *  	- 类内可以定义属性、方法、构造器等
 *  	- 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承
 *  	- 可以abstract修饰
 *
 * 4.关注如下的3个问题
 *   》 如何实例化成员内部类的对象
 *   》 如何在成员内部类中区分调用外部类的结构
 *   》 开发中局部内部类的使用  见《InnerClassTest1.java》


 /*
  * 1.匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。
  * 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。
  *
  * 2.格式：
  * 		new 父类构造器（实参列表）|实现接口(){
  * 				//匿名内部类的类体部分
  * 		}
  *
  * 3.匿名内部类的特点
  * 		> 匿名内部类必须继承父类或实现接口
  * 		> 匿名内部类只能有一个对象
  * 		> 匿名内部类对象只能使用多态形式引用
  */
   */


异常
   在Java语言中，将程序执行中发生的不正常情况称为“异常”。

Java程序在执行过程中所发生的异常事件可分为两类：
   Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。
        比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。

Exception:其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：
    1，空指针访问
    2，试图读取不存在的文件
    3，网络连接中断
    4，数组角标越界

    对于这些错误，一般有两种解决方法：

    一是遇到错误就终止程序的运行。
    另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。
    捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如：除数为0，数组下标越界等

    异常分类：编译时异常和运行时异常

运行时异常
    是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。
    对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。

编译时异常
    是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。
    对于这类异常，如果程序不处理，可能会带来意想不到的结果。

03、异常处理机制一：try-catch-finally
    在编写程序时，经常要在可能出现错误的地方加上检测的代码，如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据而是字符等。过多的if-else分支会导致程序的代码加长、臃肿，可读性差。因此采用异常处理机制。

    Java异常处理:

    Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。

    方式一：try-catch-finally

    方式二：throws + 异常类型

        Java异常处理的方式: try-catch-finally



    try
        捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现异常的代码放在try语句块中。
    catch(Exceptiontypee)
    在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。
    捕获异常的有关信息：与其它对象一样，可以访问一个异常对象的成员变量或调用它的方法。
        getMessage() 获取异常信息，返回字符串
        printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。

    finally

    捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。
    不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return，finally块中的语句都会被执行。
    finally语句和catch语句是任选的


/*
 * 异常的处理:抓抛模型
 *
 * 过程一:“抛”：程序在征程执行过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象
 * 			 并将此对象抛出。
 * 			一旦抛出对象以后，其后的代码就不再执行。
 *
 * 过程二:“抓”:可以理解为异常的处理方式：① try-catch-finally  ② throws
 *
 * 二、try-catch-finally的使用
 *
 * try{
 * 		//可能出现异常的代码
 * }catch(异常类型1 变量名1){
 * 		//处理异常的方式1
 * }catch(异常类型2 变量名2){
 * 		//处理异常的方式2
 * }catch(异常类型3 变量名3){
 * 		//处理异常的方式3
 * }
 * ...
 * finally{
 * 		//一定会执行的代码
 * }
 *
 * 说明:
 * 1.finally是可选的。
 * 2.使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象
 *   的类型，去catch中进行匹配。
 * 3.一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的
 *   try-catch结构（在没有写finally的情况）。继续执行其后的代码。
 * 4.catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。
 *   catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错
 * 5.常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()
 * 6.在try结构中声明的变量，再出了try结构以后，就不能再被调用,例65行:System.out.println(num);
 * 7.try-catch-finally结构可以嵌套
 *
 * 体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。
 *     相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。
 *
 * 体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。
 *      针对于编译时异常，我们说一定要考虑异常的处理。

  * try-catch-finally中finally的使用：
  *
  * 1.finally是可选的。
  * 2.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有
  *   return语句等情况。
  * 3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的
  *   释放。此时的资源释放，就需要声明在finally中。
  *

异常处理机制二：throws

    声明抛出异常是Java中处理异常的第二种方式
        如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。
    在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。


/*
 * 异常处理的方式二：throws + 异常类型
 *
 * 1. "throws + 异常类型"写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。
 *     一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常
 *     类型时，就会被抛出。异常代码后续的代码，就不再执行！
 *
 *     关于异常对象的产生:① 系统自动生成的异常对象
 * 					② 手动生成一个异常对象，并抛出(throw)
 *
 * 2. 体会：try-catch-finally:真正的将异常给处理掉了。
 *        throws的方式只是将异常抛给了方法的调用者。  并没有真正将异常处理掉。
 *
 */
 */





 *
