 * 三、面向对象的两个要素：
 * 类:对一类事物的描述，是抽象的、概念上的定义
 * 对象:是实际存在的该类事物的每个个体，因而也称为实	例(instance)。
 * 可以理解为：类= 抽象概念的人；对象= 实实在在的某个人
 * 面向对象程序设计的重点是类的设计；
 * 设计类，其实就是设计类的成员。

  一、设计类、其实就是设计类的成员
  * Field = 属性 = 成员变量 = 域、字段
  * Method = (成员)方法 = 函数
  *
  * 创建类 = 类的实例化 = 实例化类
  *
  * 二.类和对象的使用(面向对象思想落地的实现)
  * 1.创建类，设计类的成员
  * 2.创建类的对象
  * 3.通过“对象.属性”或“对象.方法”调用对象的结构
  * 三、如果创建类一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非 static 的)
  * 	  意味着:如果我们修改一个对象的属性 a，则不影响另外一个对象属性 a 的值。

/*
 * 类的语法格式：
 * 修饰符 class 类名{
 * 		属性声明;
 * 		方法声明;
 * }
 * 说明：修饰符 public：类可以被任意访问类的正文要用{  }括起来
 */


 类的成员之一：属性

 /*
  * 类中属性的使用
  *
  * 属性(成员变量)	vs	局部变量
  * 1.相同点:
  * 		1.1 定义变量的格式:数据类型 变量名 = 变量值
  * 		1.2 先声明，后使用
  * 		1.3 变量都有其对应的作用域
  *
  * 2.不同点:
  * 		2.1 在类中声明的位置不同
  * 		属性:直接定义在类的一对{}内
  * 		局部变量:声明在方法内、方法形参、构造器形参、构造器内部的变量
  *
  * 		2.2 关于权限修饰符的不同
  * 		属性:可以在声明属性时，指明其权限，使用权限修饰符。
  * 			常用的权限修饰符:private、public、缺省、protected
  * 			目前声明属性时，都使用缺省即可。
  * 		局部变量:不可以使用权限修饰符。
  *
  * 		2.3 默认初始化值的情况:
  * 		属性:类的属性，根据其类型，都有默认初始化值。
  * 			整型(byte、short、int、long):0
  * 			浮点型(float、double):0.0
  * 			字符型(char):0(或‘\u0000’)
  * 			布尔型(boolean):false
  *
  * 			引用数据类型(类、数组、接口):null
  *
  * 		局部变量:没有默认初始化值
  * 			意味着:在调用局部变量之前，一定要显式赋值。
  * 			特别地:形参在调用时,赋值即可。例，45 行
  *
  * 		2.4 在内存中加载的位置，亦各不相同。
  * 		属性:加载到堆空间中(非 static)
  * 		局部变量:加载到栈空间
  */
类中方法的声明和使用
   *
   * 方法：描述类应该具有的功能。
   * 比如：Math类：sqrt()\random() \...
   *     Scanner类：nextXxx() ...
   *     Arrays类：sort() \ binarySearch() \ toString() \ equals() \ ...
   *
   * 1.举例：
   * public void eat(){}
   * public void sleep(int hour){}
   * public String getName(){}
   * public String getNation(String nation){}
   *
   * 2. 方法的声明：权限修饰符  返回值类型  方法名(形参列表){
   * 					方法体
   * 			  }
   *   注意：static、final、abstract 来修饰的方法，后面再讲。
   *
   * 3. 说明：
   * 		3.1 关于权限修饰符：默认方法的权限修饰符先都使用public
   * 			Java规定的4种权限修饰符：private、public、缺省、protected  -->封装性再细说
   *
   * 		3.2 返回值类型： 有返回值  vs 没有返回值
   * 			3.2.1  如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用
   *                return关键字来返回指定类型的变量或常量：“return 数据”。
   * 				  如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要
   *               使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。
   *
   * 			3.2.2 我们定义方法该不该有返回值？
   * 				① 题目要求
   * 				② 凭经验：具体问题具体分析
   *
   *      3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”
   *      3.4 形参列表:方法名可以声明0个、1个，或多个形参。
   *      	3.4.1 格式:数据类型1 形参1，数据类型2 形参2,...
   *
   *      	3.4.2 我们定义方法时，该不该定义形参？
   *      		① 题目要求
   *      		② 凭经验，具体问题具体分析
   *      3.5 方法体:方法功能的体现。
   *  4. return关键字的使用：
   *  	1.使用范围:使用在方法体中
   *  	2.作业:① 结束方法
   *  		  ② 针对于有返回值类型的方法，使用"return 数据"方法返回所要的数据。
   *  	3.注意点:return关键字后不可声明执行语句。
   *  5. 方法的使用中，可以调用当前类的属性或方法。
   *  		特殊的:方法A中又调用了方法A:递归方法。
   *  	方法中不能定义其他方法。

方法的重载(overload) loading...
    *
    * 1.定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。
    *
    * 		“两同一不同”:同一个类、相同方法名
    * 				  参数列表不同：参数个数不同，参数类型不同
    *
    * 2.举例:
    * 		Arrays类中重载的sort() / binarySearch()
    *
    * 3.判断是否重载
    * 		与方法的返回值类型、权限修饰符、形参变量名、方法体都无关。
    *
    * 4.在通过对象调用方法时，如何确定某一个指定的方法：
    * 		方法名---》参数列表
    */

     * 可变个数形参的方法
     * 1.jdk 5.0新增的内容
     * 2.具体使用：
     * 	2.1 可变个数形参的格式：数据类型 ... 变量名
     * 	2.2 当调用可变个数形参的方法时，传入的参数的个数可以是：0个，1个，2个...
     * 	2.3可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。
     *  2.4可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。即二者不可共存。
     *  2.5可变个数形参在方法中的形参中,必须声明在末尾。
     *  2.6可变个数形参在方法中的形参中，最多只能声明一个可变形参。

方法参数的值传递机制(重点！！！)

/*
 * 关于变量的赋值
 *
 * 	如果变量是基本数据类型，此时赋值的是变量所保存的数据值。
 * 	如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。
 *
 */

 针对基本数据类型

 /*
  * 方法的形参的传递机制：值传递
  *
  * 1.形参：方法定义时，声明的小括号内的参数
  *   实参：方法调用时，实际传递给形参的数据
  *
  * 2.值传递机制：
  *  如果参数是基本数据类型，此时实参赋值给形参的是实参真是存储的数据值。
  */

  面向对象特征之一：封装与隐藏
  意义：为了不想让外部随意对类中的属性更改，将属性私有化，
       但是这样外部不能使用类内部的属性，通过提供public get/set方法给外部调用解决。

  面向对象的特征一:封装与隐藏
   * 一、问题的引入：
   *    当我们创建一个类的对象以后，我们可以通过"对象.属性"的方式，对对象的属性进行赋值。这里，赋值操作要受到
   *    属性的数据类型和存储范围的制约。但除此之外，没有其他制约条件。但是，实际问题中，我们往往需要给属性赋值
   *    加入额外限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行条件的添加。比如说，setLegs
   *    同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private)
   *    --》此时，针对于属性就体现了封装性。
   *
   * 二、封装性的体现：
   *    我们将类的属性私有化(private),同时,提供公共的(public)方法来获取(getXxx)和设置(setXxx)
   *
   *    拓展：封装性的体现：① 如上 ② 单例模式 ③ 不对外暴露的私有方法
   *
   */
  类的成员变量权限修饰：
        public、protected、default(缺省)、private 置于类的成员定义前，用来限定对象对该类成员的访问权限。

  对于 class 的权限修饰只可以用 public 和 default(缺省)。
      public 类可以在任意地方被访问。
      default 类只可以被同一个包内部的类访问。

   * 三、封装性的体现，需要权限修饰符来配合。
   *   1.Java 规定的 4 种权限：(从小到大排序)private、缺省、protected、public
   *   2.4 种权限用来修饰类及类的内部结构：属性、方法、构造器、内部类
   *   3.具体的，4 种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类
   * 		 修饰类的话，只能使用：缺省、public
   *  总结封装性：Java 提供了 4 中权限修饰符来修饰类积累的内部结构，体现类及类的内部结构的可见性的方法。
   *
        private :只能在类内部使用，出了类就不能用
        缺省：同一个包内用
        protected:不同包的子类可用
        public ：同一个工程可用
   */
